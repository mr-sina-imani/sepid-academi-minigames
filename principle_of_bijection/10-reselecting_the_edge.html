<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <style>
        :root {
            --bg-color: #f1f5f9;
            --text-main: #1e293b;
            --u-color: #2563eb; /* Blue */
            --v-color: #dc2626; /* Red */
            --edge-idle: #cbd5e1;
            --edge-active: #475569; /* Dark Gray */
            --success: #10b981;
            --error: #eabc03;
            --warning: #14b017;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: 0;
            padding: 20px;
            user-select: none;
        }

        h1 { margin-bottom: 0.5rem; }
        p { color: #64748b; margin-bottom: 2rem; text-align: center; max-width: 650px;}

        #game-container {
            position: relative;
            background: #fff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            min-width: 750px;
            align-items: center;
        }

        svg { cursor: default; }

        /* Edges */
        line.edge {
            stroke: var(--edge-idle);
            stroke-width: 2;
            transition: stroke 0.3s, stroke-width 0.3s;
            stroke-linecap: round;
        }

        line.edge.active {
            stroke: var(--edge-active);
            stroke-width: 6;
        }
        
        line.edge.success { stroke: var(--success); }

        /* Vertices */
        circle.vertex {
            fill: #fff;
            stroke: var(--text-main);
            stroke-width: 2;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        circle.vertex:hover { stroke-width: 4; fill: #f8fafc; }

        /* Selection Colors */
        circle.vertex.selected-1 { fill: var(--u-color); stroke: var(--u-color); stroke-width: 0; }
        circle.vertex.selected-2 { fill: var(--v-color); stroke: var(--v-color); stroke-width: 0; }

        /* Status Bar */
        #status-bar {
            margin-top: 20px;
            font-size: 1.1rem;
            font-weight: 600;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 0 20px;
            border-radius: 6px;
            transition: background-color 0.3s, color 0.3s;
        }

        .status-normal { background-color: transparent; color: var(--text-main); }
        .status-error { background-color: #fef2f2; color: var(--error); }
        .status-success { background-color: #ecfdf5; color: var(--success); }
        .status-warning { background-color: #fffbeb; color: var(--warning); }
        
        .hint { font-size: 0.85rem; color: #94a3b8; margin-top: 8px; font-weight: normal; }

    </style>
</head>
<body>
    <div id="game-container">
        <svg id="polygon-svg" width="500" height="400"></svg>

        <div id="status-bar" class="status-normal" dir="rtl">دور اول: یک مدیر و معاون انتخاب کن...</div>
        <div id="hint-text" class="hint"></div>
    </div>

    <script>
        // --- Configuration ---
        const SVG_NS = "http://www.w3.org/2000/svg";
        const DELAY_MS = 250; 

        // Irregular Convex Quadrilateral
        const verticesData = [
            { id: 0, x: 120, y: 80 }, 
            { id: 1, x: 400, y: 60 },  
            { id: 2, x: 340, y: 320 }, 
            { id: 3, x: 80, y: 280 }   
        ];

        // --- State ---
        let gamePhase = 1; // 1 = First Selection, 2 = Reverse Selection, 3 = Game Over
        let round1Pair = []; // Stores [id1, id2]
        let currentSelection = []; // Stores current clicks
        let isLocked = false; 

        // --- DOM Elements ---
        const svg = document.getElementById('polygon-svg');
        const statusBar = document.getElementById('status-bar');
        const hintText = document.getElementById('hint-text');

        // --- Initialization ---
        function initGame() {
            renderGraph();
            document.addEventListener('keydown', handleKeyInput);
        }

        function renderGraph() {
            svg.innerHTML = ''; 
            // Draw Edges
            for (let i = 0; i < verticesData.length; i++) {
                for (let j = i + 1; j < verticesData.length; j++) {
                    createEdge(verticesData[i], verticesData[j]);
                }
            }
            // Draw Vertices
            verticesData.forEach(v => createVertex(v));
        }

        function createEdge(v1, v2) {
            const line = document.createElementNS(SVG_NS, 'line');
            line.setAttribute('x1', v1.x); line.setAttribute('y1', v1.y);
            line.setAttribute('x2', v2.x); line.setAttribute('y2', v2.y);
            line.classList.add('edge');
            
            // ID format: edge-min-max
            const min = Math.min(v1.id, v2.id);
            const max = Math.max(v1.id, v2.id);
            line.id = `edge-${min}-${max}`;
            svg.appendChild(line);
        }

        function createVertex(v) {
            const circle = document.createElementNS(SVG_NS, 'circle');
            circle.setAttribute('cx', v.x); circle.setAttribute('cy', v.y);
            circle.setAttribute('r', 12);
            circle.classList.add('vertex');
            circle.id = `vertex-${v.id}`;
            
            circle.addEventListener('click', () => handleVertexClick(v.id));
            svg.appendChild(circle);
        }

        // --- Interaction Logic ---

        function handleVertexClick(id) {
            if (isLocked || gamePhase === 3) return;

            // Prevent selecting same node twice in one pair
            if (currentSelection.length === 1 && currentSelection[0] === id) return;

            currentSelection.push(id);
            updateVertexVisuals(id, currentSelection.length);

            if (currentSelection.length === 1) {
                setStatus(`مدیر انتخاب شد. حالا معاون!`, 'normal');
            } 
            else if (currentSelection.length === 2) {
                isLocked = true; // Lock input during hesitation/processing
                
                // Small visual delay before calculating result
                setTimeout(() => {
                    processPairSelection();
                }, DELAY_MS);
            }
        }

        function processPairSelection() {
            const [u, v] = currentSelection;
            const edgeId = getEdgeId(u, v);
            const edgeEl = document.getElementById(edgeId);

            if (gamePhase === 1) {
                // --- Round 1 Logic ---
                edgeEl.classList.add('active'); // Highlight Edge
                round1Pair = [u, v]; // Save the order
                
                setStatus("تیم تشکیل شد! حالا Space رو بزن تا انتخاب بعدی رو انجام بدی", "success");
                hintText.textContent = "";
                
                // Note: We stay locked until Space is pressed
            } 
            else if (gamePhase === 2) {
                // --- Round 2 Logic ---
                
                // 1. Check if they found the correct edge (set equality)
                const isSameEdge = (u === round1Pair[0] && v === round1Pair[1]) || 
                                   (u === round1Pair[1] && v === round1Pair[0]);

                if (!isSameEdge) {
                    handleRound2Error("این یک تیم دیگه‌ست. یه کاری کن که همون تیم ۲ نفره ی قبلی تشکیل بشه");
                    return;
                }

                // 2. Check if they used the EXACT same order (redundancy check)
                if (u === round1Pair[0] && v === round1Pair[1]) {
                    handleRound2Error("این که همون قبلیه! یک مدیر و معاون جدید انتخاب کن");
                    return;
                }

                // 3. Success: Same edge, different order (u == v_old && v == u_old)
                edgeEl.classList.add('success'); // Turn Green
                setStatus("درسته! این مدیر و معاون هم همون تیم رو مشخص می‌کنن!", "success");
                hintText.textContent = "";
                gamePhase = 3; // End Game
            }
        }

        function handleRound2Error(msg) {
            setStatus(msg, "error");
            
            // Reset Round 2 visuals after short delay
            setTimeout(() => {
                // Clear Round 2 vertex selection
                resetVertexVisuals(); 
                currentSelection = [];
                isLocked = false; 
                setStatus("دوباره تلاش کن. (همون آدما رو با ترتیب برعکس امتحان کن!)", "warning");
            }, 5000);
        }

        function handleKeyInput(e) {
            if (e.code === 'Space') {
                if (gamePhase === 1 && round1Pair.length === 2) {
                    startRound2();
                } else if (gamePhase === 3) {
                    // Optional: Reset entire game
                    location.reload(); 
                }
            }
        }

        function startRound2() {
            gamePhase = 2;
            currentSelection = [];
            isLocked = false; // Unlock for Round 2
            
            // Visual Reset
            resetVertexVisuals(); // Clear blue/red dots
            // Note: The Edge stays 'active' (gray) from Round 1 so they know the target
            
            setStatus("دور دوم: مدیر و معاون جدید رو جوری انتخاب کن که همون تیم قبلی تشکیل بشه", "warning");
            hintText.textContent = ``;
        }

        // --- Visual Helpers ---

        function updateVertexVisuals(id, order) {
            const el = document.getElementById(`vertex-${id}`);
            if (order === 1) el.classList.add('selected-1');
            if (order === 2) el.classList.add('selected-2');
        }

        function resetVertexVisuals() {
            document.querySelectorAll('.vertex').forEach(el => {
                el.classList.remove('selected-1', 'selected-2');
            });
        }

        function getEdgeId(id1, id2) {
            const min = Math.min(id1, id2);
            const max = Math.max(id1, id2);
            return `edge-${min}-${max}`;
        }

        function setStatus(text, type) {
            statusBar.textContent = text;
            statusBar.className = ''; // Reset class
            statusBar.classList.add(`status-${type}`);
        }

        // Start
        initGame();

    </script>
</body>
</html>
