<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Path Discovery: The 2x2 Grid</title>
    <style>
        :root {
            --bg-color: #f8fafc;
            --grid-line: #94a3b8;
            --path-color: #ef4444;
            --dot-color: #1e3a8a;
            --success: #10b981;
            --warning: #f59e0b;
            --text-main: #334155;
            --card-bg: #ffffff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        h1 { margin: 0 0 10px 0; font-size: 1.8rem; }
        p { margin: 0 0 20px 0; color: #64748b; text-align: center; max-width: 800px; }

        /* Main 3-Column Layout */
        #game-layout {
            display: flex;
            justify-content: center;
            gap: 40px;
            width: 100%;
            max-width: 1200px;
            height: 600px; /* Fixed height container */
        }

        /* Columns */
        .column {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Left & Right Columns (Storage) */
        .storage-col {
            width: 200px;
            gap: 15px;
            justify-content: flex-start;
            padding-top: 20px;
        }

        .storage-header {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 10px;
            color: #475569;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Center Column (Active Game) */
        #center-col {
            flex: 1;
            max-width: 500px;
            justify-content: center;
            background: #fff;
            border-radius: 20px;
            box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1);
            padding: 30px;
            position: relative;
        }

        /* --- The Discovery Zone (Big Grid) --- */
        #discovery-zone {
            --size: 300px;
            width: var(--size);
            height: var(--size);
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            border-left: 2px solid var(--grid-line);
            border-bottom: 2px solid var(--grid-line);
            position: relative;
            margin-bottom: 20px;
        }

        .grid-cell {
            border-top: 2px solid var(--grid-line);
            border-right: 2px solid var(--grid-line);
        }

        /* --- The Small Tableau Grids --- */
        .tableau-slot {
            width: 80px;
            height: 80px;
            border: 1px dashed #cbd5e1;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fff;
            position: relative;
        }

        .tableau-grid {
            width: 60px;
            height: 60px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            border-left: 1px solid #cbd5e1;
            border-bottom: 1px solid #cbd5e1;
            position: relative;
        }

        .tableau-grid .t-cell {
            border-top: 1px solid #cbd5e1;
            border-right: 1px solid #cbd5e1;
        }

        /* --- String Placeholders --- */
        .string-slot {
            width: 140px;
            height: 80px; /* Match tableau height */
            background: #e2e8f0;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 1.5rem;
            font-weight: bold;
            color: #475569;
            letter-spacing: 3px;
            border: 1px solid transparent;
        }

        .string-slot.filled {
            background: #dbeafe;
            color: #1e3a8a;
            border-color: #93c5fd;
            animation: popIn 0.3s ease-out;
        }

        /* --- SVGs --- */
        .path-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }

        path.trajectory {
            fill: none;
            stroke: var(--path-color);
            stroke-width: 6;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        path.mini-trajectory {
            fill: none;
            stroke: var(--path-color);
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        /* --- Dot & Markers --- */
        #current-dot {
            position: absolute;
            width: 10px;
            height: 10px;
            background: var(--dot-color);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.15s ease-out;
            z-index: 10;
        }
        
        .marker {
            position: absolute;
            width: 12px; height: 12px;
            background: var(--success);
            border-radius: 50%;
        }
        #start-mark { bottom: -6px; left: -6px; }
        #end-mark { top: -6px; right: -6px; }

        /* --- Feedback Area --- */
        #message-area {
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            text-align: center;
        }
        
        .msg-new { color: var(--success); animation: flashGreen 1s; }
        .msg-dup { color: var(--warning); animation: flashOrange 1s; }
        .msg-done { color: var(--dot-color); font-size: 1.4rem; }

        @keyframes popIn { 0% { transform: scale(0.8); opacity: 0; } 100% { transform: scale(1); opacity: 1; } }
        @keyframes flashGreen { 0% { opacity: 0; transform: translateY(10px); } 20% { opacity: 1; transform: translateY(0); } 80% { opacity: 1; } 100% { opacity: 0; } }
        @keyframes flashOrange { 0% { opacity: 0; transform: translateY(10px); } 20% { opacity: 1; transform: translateY(0); } 80% { opacity: 1; } 100% { opacity: 0; } }

    </style>
</head>
<body>

    <h1>Discover All Paths (2 x 2)</h1>
    <p>
        Use <strong>Arrow Keys</strong> (Up/Right) to find every valid path from bottom-left to top-right. <br>
        There are 6 possible paths. Can you find them all?
    </p>

    <div id="game-layout">
        
        <div class="column storage-col" id="col-left">
            <div class="storage-header">Paths Found</div>
            </div>

        <div class="column" id="center-col">
            <div id="message-area">Start moving!</div>
            
            <div id="discovery-zone">
                <svg id="main-svg" class="path-svg"></svg>
                
                <div class="grid-cell"></div><div class="grid-cell"></div>
                <div class="grid-cell"></div><div class="grid-cell"></div>

                
                <div id="current-dot"></div>
            </div>

            <div style="color: #94a3b8; font-size: 0.9rem;">
                Paths Discovered: <span id="counter" style="color:var(--text-main); font-weight:bold;">0</span> / 6
            </div>
        </div>

        <div class="column storage-col" id="col-right">
            <div class="storage-header">String Notation</div>
            </div>

    </div>

    <script>
        // --- Constants ---
        const GRID_SIZE = 2; // 2x2 grid
        const PIXEL_SIZE = 300; // Big grid size in px
        const CELL_PX = PIXEL_SIZE / GRID_SIZE; // 150px
        const TOTAL_PATHS = 6; // C(4,2)
        
        // --- State ---
        let currentPos = { x: 0, y: 0 }; // (0,0) is bottom-left relative to grid logic
        let pathHistory = [{ x: 0, y: 0 }];
        let currentString = "";
        let foundPaths = new Set(); // Stores strings "RRUU", "RURU" etc.
        let isResetting = false;

        // --- DOM Elements ---
        const dot = document.getElementById('current-dot');
        const mainSvg = document.getElementById('main-svg');
        const msgArea = document.getElementById('message-area');
        const counterEl = document.getElementById('counter');
        const colLeft = document.getElementById('col-left');
        const colRight = document.getElementById('col-right');

        // --- Initialization ---
        function init() {
            // Generate Empty Slots
            for(let i=0; i<TOTAL_PATHS; i++) {
                // Left Tableau Slot
                const tSlot = document.createElement('div');
                tSlot.className = 'tableau-slot';
                tSlot.id = `t-slot-${i}`;
                // Inner grid for visuals
                tSlot.innerHTML = `
                    <div class="tableau-grid">
                        <svg class="path-svg" id="mini-svg-${i}"></svg>
                        <div class="t-cell"></div><div class="t-cell"></div>
                        <div class="t-cell"></div><div class="t-cell"></div>
                    </div>
                `;
                colLeft.appendChild(tSlot);

                // Right String Slot
                const sSlot = document.createElement('div');
                sSlot.className = 'string-slot';
                sSlot.id = `s-slot-${i}`;
                sSlot.innerHTML = ''; 
                colRight.appendChild(sSlot);
            }
            
            resetDiscoveryZone();
            document.addEventListener('keydown', handleInput);
        }

        // --- Core Logic ---

        function handleInput(e) {
            if (isResetting || foundPaths.size === TOTAL_PATHS) return;

            let moved = false;
            let moveChar = '';

            if (e.key === 'ArrowRight') {
                if (currentPos.x < GRID_SIZE) {
                    currentPos.x++;
                    moved = true;
                    moveChar = 'R';
                }
            } else if (e.key === 'ArrowUp') {
                if (currentPos.y < GRID_SIZE) {
                    currentPos.y++;
                    moved = true;
                    moveChar = 'U';
                }
            }

            if (moved) {
                e.preventDefault();
                pathHistory.push({ ...currentPos });
                currentString += moveChar;
                updateVisuals();
                checkCompletion();
            }
        }

        function updateVisuals() {
            // Update Dot
            // CSS Coords: Left=0 is x=0. Top=0 is y=GRID_SIZE (math)
            dot.style.left = `${currentPos.x * CELL_PX}px`;
            dot.style.top = `${(GRID_SIZE - currentPos.y) * CELL_PX}px`;

            // Draw SVG Line
            drawPath(mainSvg, pathHistory, CELL_PX, 6, "trajectory");
        }

        function drawPath(svgElement, history, scale, strokeWidth, className) {
            if (history.length < 2) return;

            // Offset logic to prevent clipping (Line centered between grid lines)
            // If line is on edge 0, shift +offset. If on edge MAX, shift -offset.
            const offset = 0;//strokeWidth / 2; 
            const maxPx = GRID_SIZE * scale;

            let d = "";

            history.forEach((pt, index) => {
                let px = pt.x * scale;
                let py = (GRID_SIZE - pt.y) * scale;

                // Adjust X
                if (px === 0) px += offset;
                else if (px === maxPx) px -= offset;

                // Adjust Y
                if (py === 0) py += offset;
                else if (py === maxPx) py -= offset;

                if (index === 0) d += `M ${px} ${py} `;
                else d += `L ${px} ${py} `;
            });

            // Clear old path
            svgElement.innerHTML = '';
            
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute('d', d);
            path.classList.add(className);
            svgElement.appendChild(path);
        }

        function checkCompletion() {
            // Check if reached top-right (2, 2)
            if (currentPos.x === GRID_SIZE && currentPos.y === GRID_SIZE) {
                processResult();
            }
        }

        function processResult() {
            isResetting = true;

            if (foundPaths.has(currentString)) {
                // Duplicate
                showMessage("Already found!", "dup");
                setTimeout(resetDiscoveryZone, 1000);
            } else {
                // New Path
                savePath(currentString, [...pathHistory]);
                showMessage("New Path Found!", "new");
                
                if (foundPaths.size === TOTAL_PATHS) {
                    showMessage("CONGRATULATIONS! All paths found.", "done");
                    // Don't reset, let them bask in glory
                } else {
                    setTimeout(resetDiscoveryZone, 1000);
                }
            }
        }

        function savePath(str, history) {
            const index = foundPaths.size; // 0 to 5
            foundPaths.add(str);
            counterEl.innerText = foundPaths.size;

            // 1. Draw Mini Path on Left
            const miniSvg = document.getElementById(`mini-svg-${index}`);
            // Mini scale: Slot is 60px grid. 2x2. Cell is 30px.
            drawPath(miniSvg, history, 30, 3, "mini-trajectory");
            
            // 2. Write String on Right
            const strSlot = document.getElementById(`s-slot-${index}`);
            strSlot.innerText = str;
            strSlot.classList.add('filled');
        }

        function resetDiscoveryZone() {
            if(foundPaths.size === TOTAL_PATHS) return; // Stop resets if won

            currentPos = { x: 0, y: 0 };
            pathHistory = [{ x: 0, y: 0 }];
            currentString = "";
            isResetting = false;

            updateVisuals();
            mainSvg.innerHTML = ''; // Clear lines
            msgArea.innerText = "Find the next path...";
            msgArea.className = ""; // remove animation classes
        }

        function showMessage(text, type) {
            msgArea.innerText = text;
            msgArea.className = ""; // reset
            void msgArea.offsetWidth; // trigger reflow for animation restart
            if (type === 'new') msgArea.classList.add('msg-new');
            if (type === 'dup') msgArea.classList.add('msg-dup');
            if (type === 'done') msgArea.classList.add('msg-done');
        }

        // Start
        init();

    </script>
</body>
</html>
