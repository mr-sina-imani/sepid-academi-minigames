<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pair-to-Edge Matching Game (Final Arrow Mapping)</title>
    <style>
        :root {
            --bg-color: #f8fafc;
            --text-main: #1e293b;
            --u-color: #2563eb; 
            --v-color: #dc2626; 
            --edge-color: #475569; 
            --box-idle: #e2e8f0;
            --box-hover: #cbd5e1;
            --box-selected: #93c5fd;
            --box-matched: #dcfce7;
            --vertex-idle: #cbd5e1;
            --success: #10b981;
            --error: #ef4444;
            --arrow-color: #16a34a; /* Darker Green for arrows */
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }

        h1 { margin-bottom: 0.5rem; }
        p { color: #64748b; margin-bottom: 2rem; text-align: center; max-width: 800px; }

        /* --- Game Layout Container --- */
        #game-wrapper {
            position: relative;
            width: 100%;
            max-width: 1200px;
            min-height: 650px; /* Ensure enough height for the overall flow */
        }
        
        /* --- Mapping SVG Layer (for Arrows) --- */
        #mapping-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to the boxes */
            z-index: 10;
        }

        .match-arrow {
            fill: none;
            stroke: var(--arrow-color);
            stroke-width: 2;
            marker-end: url(#arrowhead);
            opacity: 0.8;
            transition: stroke 0.3s;
        }

        /* --- Column Layout (Content) --- */
        #game-layout {
            display: flex;
            justify-content: space-between;
            gap: 150px; /* Increased horizontal distance for arrows */
            min-height: inherit;
        }

        .column {
            display: flex;
            flex-direction: column;
            width: 50%;
            gap: 15px;
            align-items: center;
        }
        
        #pairs-col { width: calc(50% - 75px); }
        #edges-col { width: calc(50% - 75px); justify-content: center; align-content: center; }

        /* ... [Other CSS styles remain largely the same] ... */

        .col-header {
            font-size: 1.3rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--box-idle);
            width: 90%; 
        }

        /* --- Individual Boxes (Clickable Units) --- */
        .pair-box {
            position: relative;
            width: 100%;
            height: 80px; 
            border: 2px solid var(--box-idle);
            border-radius: 8px;
            background: #fff;
            transition: all 0.2s ease;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .edge-box { 
            position: relative;
            width: 80%; 
            height: 120px; 
            border: 2px solid var(--box-idle);
            border-radius: 8px;
            background: #fff;
            transition: all 0.2s ease;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }


        .pair-box:hover, .edge-box:hover {
            border-color: var(--box-hover);
        }

        .selected {
            border-color: var(--box-selected) !important;
            box-shadow: 0 0 0 4px var(--box-selected);
            transform: scale(1.02);
        }
        
        .matched {
            background-color: var(--box-matched);
            pointer-events: none;
            opacity: 0.5;
        }

        .pair-box.matched-target { opacity: 0.5; }

        /* --- SVG Styling for Minimized Shapes --- */
        .mini-svg {
            position: absolute;
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90px;
            height: 90px;
        }
        
        /* Vertices */
        .mini-vertex {
            fill: #fff;
            stroke: var(--vertex-idle);
            stroke-width: 1;
        }

        /* Edges */
        .mini-edge {
            stroke: var(--vertex-idle);
            stroke-width: 1;
            stroke-linecap: round;
        }

        /* Highlighted Elements within the Boxes */
        .pair-box .highlight-u { fill: var(--u-color); stroke: var(--u-color); stroke-width: 0; }
        .pair-box .highlight-v { fill: var(--v-color); stroke: var(--v-color); stroke-width: 0; }
        .edge-box .highlight-edge { stroke: var(--edge-color); stroke-width: 4; }

        /* --- Status and Reset --- */
        #status-message {
            margin-top: 30px;
            font-size: 1.5rem;
            font-weight: bold;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: var(--text-main);
        }

        #reset-btn {
            padding: 10px 20px;
            margin-top: 20px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            color: white;
            background-color: var(--edge-color);
            transition: background-color 0.2s;
            display: none;
        }

        #reset-btn:hover { background-color: #1e293b; }

    </style>
</head>
<body>

    <h1>Map Pairs to Edges (4 Vertices)</h1>
    <p>
        There are 12 possible ordered pairs $(u, v)$ (Left Column) and only 6 possible edges $\{u, v\}$ (Right Column).<br>
        Match every pair on the left to its corresponding edge on the right to visualize the mapping.
    </p>

    <div id="game-wrapper">
        <svg id="mapping-svg">
             <defs>
                <marker id="arrowhead" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--arrow-color)" />
                </marker>
            </defs>
        </svg>

        <div id="game-layout">
            <div class="column" id="pairs-col">
                <div class="col-header">Ordered Pairs (u, v): 12 Total</div>
                </div>

            <div class="column" id="edges-col">
                <div class="col-header">Edges {u, v}: 6 Total</div>
                </div>
        </div>
    </div>

    <div id="status-message">Click an ordered pair (Left) and then its resulting edge (Right).</div>
    <button id="reset-btn">Reset All Matches</button>

    <script>
        // --- Configuration ---
        const SVG_NS = "http://www.w3.org/2000/svg";
        const TOTAL_PAIRS = 12;
        const VERTICES_IDS = [0, 1, 2, 3]; 

        // Coordinates (Scaled down for mini-SVG)
        const scaleFactor = 90 / 400; 
        const verticesData = [
            { id: 0, x: 120 * scaleFactor, y: 80 * scaleFactor },
            { id: 1, x: 400 * scaleFactor, y: 60 * scaleFactor },
            { id: 2, x: 340 * scaleFactor, y: 320 * scaleFactor },
            { id: 3, x: 80 * scaleFactor, y: 280 * scaleFactor }
        ];

        // --- State ---
        let selectedPairId = null; 
        let matchedPairsCount = 0; 
        let matches = {}; 

        // --- DOM Elements ---
        const pairsCol = document.getElementById('pairs-col');
        const edgesCol = document.getElementById('edges-col');
        const statusMessage = document.getElementById('status-message');
        const resetBtn = document.getElementById('reset-btn');
        const mappingSvg = document.getElementById('mapping-svg');
        const gameWrapper = document.getElementById('game-wrapper');

        // --- Core Functions ---

        function initGame() {
            generatePairBoxes();
            generateEdgeBoxes();
            
            // Adjust SVG size to wrapper size for arrow drawing
            const resizeObserver = new ResizeObserver(entries => {
                const rect = entries[0].contentRect;
                mappingSvg.setAttribute('width', rect.width);
                mappingSvg.setAttribute('height', rect.height);
            });
            resizeObserver.observe(gameWrapper);

            resetBtn.addEventListener('click', resetGame);
            resetBtn.style.display = 'block';
        }

        function generateCanonicalEdgeId(u, v) {
            return `${Math.min(u, v)}-${Math.max(u, v)}`;
        }

        // --- Box Generation (Same as previous, omitted for brevity, but included in final code) ---
        // ... (generatePairBoxes, generateEdgeBoxes, createBox, drawMiniPolygon) ...
        function generatePairBoxes() {
            let pairIndex = 0;
            for (let u of VERTICES_IDS) {
                for (let v of VERTICES_IDS) {
                    if (u !== v) {
                        const box = createBox('pair', pairIndex, u, v);
                        pairsCol.appendChild(box);
                        pairIndex++;
                    }
                }
            }
        }

        function generateEdgeBoxes() {
            let edgeIndex = 0;
            for (let i = 0; i < VERTICES_IDS.length; i++) {
                for (let j = i + 1; j < VERTICES_IDS.length; j++) {
                    const u = VERTICES_IDS[i];
                    const v = VERTICES_IDS[j];
                    const canonicalId = generateCanonicalEdgeId(u, v);
                    
                    const box = createBox('edge', edgeIndex, u, v, canonicalId);
                    edgesCol.appendChild(box);
                    matches[canonicalId] = []; 
                    edgeIndex++;
                }
            }
        }

        function createBox(type, index, u, v, canonicalId = null) {
            const box = document.createElement('div');
            box.classList.add(type === 'pair' ? 'pair-box' : 'edge-box');
            box.dataset.index = index;
            box.dataset.u = u;
            box.dataset.v = v;
            box.id = `${type}-${index}`;
            
            box.innerHTML = `
                <svg class="mini-svg" viewBox="0 0 100 100">
                    ${drawMiniPolygon(u, v, type)}
                </svg>
            `;
            
            if (type === 'pair') {
                box.dataset.canonicalId = generateCanonicalEdgeId(u, v);
                box.addEventListener('click', () => handlePairSelect(box, index));
            } else { 
                box.dataset.canonicalId = canonicalId;
                box.addEventListener('click', () => handleEdgeSelect(box));
            }

            return box;
        }
        
        function drawMiniPolygon(u, v, type) {
            let svgContent = '';
            
            for (let i = 0; i < VERTICES_IDS.length; i++) {
                for (let j = i + 1; j < VERTICES_IDS.length; j++) {
                    const p1 = verticesData[i];
                    const p2 = verticesData[j];
                    const isTargetEdge = (i === Math.min(u,v) && j === Math.max(u,v));

                    svgContent += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" 
                        class="mini-edge ${type === 'edge' && isTargetEdge ? 'highlight-edge' : ''}" />`;
                }
            }

            for (let i of VERTICES_IDS) {
                const p = verticesData[i];
                let vertexClass = 'mini-vertex';
                
                if (type === 'pair') {
                    if (i === u) vertexClass += ' highlight-u';
                    else if (i === v) vertexClass += ' highlight-v';
                }
                
                svgContent += `<circle cx="${p.x}" cy="${p.y}" r="4" class="${vertexClass}" />`;
            }

            return svgContent;
        }
        // --- Arrow Drawing Logic ---

        function drawArrow(sourceId, targetId) {
            const sourceEl = document.getElementById(sourceId);
            const targetEl = document.getElementById(targetId);
            
            const wrapperRect = gameWrapper.getBoundingClientRect();
            const sourceRect = sourceEl.getBoundingClientRect();
            const targetRect = targetEl.getBoundingClientRect();

            // Calculate coordinates relative to the central SVG overlay
            const startX = sourceRect.right - wrapperRect.left;
            const startY = sourceRect.top + sourceRect.height / 2 - wrapperRect.top;
            
            const endX = targetRect.left - wrapperRect.left;
            const endY = targetRect.top + targetRect.height / 2 - wrapperRect.top;
            
            // Use a slight curve for aesthetics and to prevent arrows overlapping too much
            const controlPointX = startX + (endX - startX) * 0.5;
            const controlPointY = startY + (endY - startY) * 0.1; 
            
            const pathData = `M ${startX} ${startY} C ${controlPointX} ${startY}, ${controlPointX} ${endY}, ${endX - 8} ${endY}`;

            const arrow = document.createElementNS(SVG_NS, 'path');
            arrow.setAttribute('d', pathData);
            arrow.classList.add('match-arrow');
            arrow.id = `arrow-${sourceId}`;
            
            mappingSvg.appendChild(arrow);
        }

        // --- Interaction Handlers ---

        function handlePairSelect(box, id) {
            if (box.classList.contains('matched-target')) return; 

            if (selectedPairId !== null) {
                document.querySelector(`.pair-box[data-index="${selectedPairId}"]`).classList.remove('selected');
            }
            
            selectedPairId = id;
            box.classList.add('selected');
            setStatus("Pair selected. Now click the corresponding edge on the right.", "normal");
        }

        function handleEdgeSelect(edgeBox) {
            if (selectedPairId === null) {
                setStatus("Please select an ordered pair on the left first.", "warning");
                return;
            }

            const pairBox = document.querySelector(`.pair-box[data-index="${selectedPairId}"]`);
            const pairCanonicalId = pairBox.dataset.canonicalId;
            const edgeCanonicalId = edgeBox.dataset.canonicalId;

            if (pairCanonicalId === edgeCanonicalId) {
                // SUCCESSFUL MATCH
                
                // 1. Draw Arrow
                drawArrow(`pair-${selectedPairId}`, edgeBox.id);

                // 2. Update box states
                pairBox.classList.remove('selected');
                pairBox.classList.add('matched-target');
                
                matches[edgeCanonicalId].push(selectedPairId);
                const count = matches[edgeCanonicalId].length;

                if (count === 1) {
                    setStatus("First match found! One arrow drawn.", "success");
                } else if (count === 2) {
                    edgeBox.classList.add('matched');
                    setStatus("Edge complete! Two arrows drawn into this edge.", "success");
                }
                
                selectedPairId = null;
                matchedPairsCount++;

                if (matchedPairsCount === TOTAL_PAIRS) {
                    endGame();
                }

            } else {
                // INCORRECT MATCH
                setStatus("Incorrect match. That pair maps to a different edge. Try again!", "error");
                
                edgeBox.classList.add('selected'); 
                setTimeout(() => {
                    edgeBox.classList.remove('selected');
                    document.querySelector(`.pair-box[data-index="${selectedPairId}"]`).classList.remove('selected');
                    selectedPairId = null;
                    setStatus("Selection reset. Pick a Pair on the left to start.", "normal");
                }, 1000);
            }
        }
        
        // --- Game Flow ---

        function endGame() {
            setStatus("CONGRATULATIONS! You have successfully mapped all 12 pairs to their 6 unique edges.", "success");
            resetBtn.textContent = "Play Again";
        }
        
        function resetGame() {
             location.reload();
        }

        // --- Utility Functions for Status Bar Styling ---

        function setStatus(text, type) {
            statusMessage.textContent = text;
            statusMessage.style.color = 'var(--text-main)';
            
            if (type === 'success') {
                statusMessage.style.color = 'var(--success)';
            } else if (type === 'warning') {
                statusMessage.style.color = 'var(--warning)';
            } else if (type === 'error') {
                statusMessage.style.color = 'var(--error)';
            } else {
                statusMessage.style.color = 'var(--text-main)';
            }
        }

        // Start Game
        initGame();

    </script>
</body>
</html>
