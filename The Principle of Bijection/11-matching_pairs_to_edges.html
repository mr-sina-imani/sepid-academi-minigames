<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pair-to-Edge Matching Game (2:1 Mapping)</title>
    <style>
        :root {
            --bg-color: #f8fafc;
            --text-main: #1e293b;
            --u-color: #2563eb; /* Blue */
            --v-color: #dc2626; /* Red */
            --edge-color: #475569; /* Dark Gray */
            --box-idle: #e2e8f0;
            --box-hover: #cbd5e1;
            --box-selected: #93c5fd;
            --box-matched: #dcfce7; /* Light Green */
            --vertex-idle: #cbd5e1;
            --success: #10b981;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }

        h1 { margin-bottom: 0.5rem; }
        p { color: #64748b; margin-bottom: 2rem; text-align: center; max-width: 800px; }

        /* --- Game Layout --- */
        #game-layout {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 1200px;
            gap: 40px;
        }

        .column {
            display: flex;
            flex-direction: column;
            width: 50%;
            gap: 15px;
        }

        .col-header {
            font-size: 1.3rem;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid var(--box-idle);
        }

        /* --- Individual Boxes (Clickable Units) --- */
        .match-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--box-idle);
            padding-bottom: 15px;
        }

        .pair-box, .edge-box {
            position: relative;
            width: 100%;
            height: 100px;
            border: 2px solid var(--box-idle);
            border-radius: 8px;
            background: #fff;
            transition: all 0.2s ease;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }

        .edge-box { width: 90%; }

        .pair-box:hover, .edge-box:hover {
            border-color: var(--box-hover);
        }

        .selected {
            border-color: var(--box-selected) !important;
            box-shadow: 0 0 0 4px var(--box-selected);
            transform: scale(1.02);
        }
        
        .matched {
            background-color: var(--box-matched);
            pointer-events: none; /* Disable clicking after match */
            opacity: 0.5;
        }

        .pair-box.matched-target { opacity: 0.5; }

        /* --- SVG Styling for Minimized Shapes --- */
        .mini-svg {
            position: absolute;
            top: 5px;
            left: 5px;
            width: 90px;
            height: 90px;
        }
        
        /* Vertices */
        .mini-vertex {
            fill: #fff;
            stroke: var(--vertex-idle);
            stroke-width: 1;
        }

        /* Edges */
        .mini-edge {
            stroke: var(--vertex-idle);
            stroke-width: 1;
            stroke-linecap: round;
        }

        /* Highlighted Elements within the Boxes */
        .pair-box .highlight-u { fill: var(--u-color); stroke: var(--u-color); stroke-width: 0; }
        .pair-box .highlight-v { fill: var(--v-color); stroke: var(--v-color); stroke-width: 0; }
        .edge-box .highlight-edge { stroke: var(--edge-color); stroke-width: 3; }

        /* --- Status and Reset --- */
        #status-message {
            margin-top: 30px;
            font-size: 1.5rem;
            font-weight: bold;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: var(--text-main);
        }

        #reset-btn {
            padding: 10px 20px;
            margin-top: 20px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            color: white;
            background-color: var(--edge-color);
            transition: background-color 0.2s;
            display: none;
        }

        #reset-btn:hover { background-color: #1e293b; }

    </style>
</head>
<body>

    <h1>Map Pairs to Edges (4 Vertices)</h1>
    <p>
        There are 12 possible ordered pairs $(u, v)$ (Left Column) and only 6 possible edges $\{u, v\}$ (Right Column).<br>
        Match every pair on the left to its corresponding edge on the right.
    </p>

    <div id="game-layout">
        <div class="column" id="pairs-col">
            <div class="col-header">Ordered Pairs (u, v): 12 Total</div>
            </div>

        <div class="column" id="edges-col">
            <div class="col-header">Edges {u, v}: 6 Total</div>
            </div>
    </div>

    <div id="status-message">Click an ordered pair (Left) and then its resulting edge (Right).</div>
    <button id="reset-btn">Reset All Matches</button>

    <script>
        // --- Configuration ---
        const SVG_NS = "http://www.w3.org/2000/svg";
        const TOTAL_PAIRS = 12;
        const VERTICES_IDS = [0, 1, 2, 3]; 

        // Irregular Polygon Coordinates (Scaled down for mini-SVG)
        const scaleFactor = 90 / 400; // SVG size / Max Y coord from previous version
        const verticesData = [
            { id: 0, x: 120 * scaleFactor, y: 80 * scaleFactor },
            { id: 1, x: 400 * scaleFactor, y: 60 * scaleFactor },
            { id: 2, x: 340 * scaleFactor, y: 320 * scaleFactor },
            { id: 3, x: 80 * scaleFactor, y: 280 * scaleFactor }
        ];

        // --- State ---
        let selectedPairId = null; // ID of the currently selected pair box
        let matchedPairsCount = 0; // Counts the 12 total matches
        
        // Key: Canonical Edge ID (e.g., "0-1"), Value: Array of Pair IDs matched to it
        let matches = {}; 

        // --- DOM Elements ---
        const pairsCol = document.getElementById('pairs-col');
        const edgesCol = document.getElementById('edges-col');
        const statusMessage = document.getElementById('status-message');
        const resetBtn = document.getElementById('reset-btn');

        // --- Core Functions ---

        function initGame() {
            generatePairBoxes();
            generateEdgeBoxes();
            resetBtn.addEventListener('click', resetGame);
            resetBtn.style.display = 'block';
        }

        function generateCanonicalEdgeId(u, v) {
            return `${Math.min(u, v)}-${Math.max(u, v)}`;
        }

        // --- Box Generation ---

        function generatePairBoxes() {
            let pairIndex = 0;
            // Generate all 12 ordered pairs (u, v) where u != v
            for (let u of VERTICES_IDS) {
                for (let v of VERTICES_IDS) {
                    if (u !== v) {
                        const box = createBox('pair', pairIndex, u, v);
                        pairsCol.appendChild(box);
                        pairIndex++;
                    }
                }
            }
        }

        function generateEdgeBoxes() {
            // Generate all 6 canonical edges
            let edgeIndex = 0;
            for (let i = 0; i < VERTICES_IDS.length; i++) {
                for (let j = i + 1; j < VERTICES_IDS.length; j++) {
                    const u = VERTICES_IDS[i];
                    const v = VERTICES_IDS[j];
                    const canonicalId = generateCanonicalEdgeId(u, v);
                    
                    const box = createBox('edge', edgeIndex, u, v, canonicalId);
                    edgesCol.appendChild(box);
                    matches[canonicalId] = []; // Initialize match array
                    edgeIndex++;
                }
            }
        }

        function createBox(type, index, u, v, canonicalId = null) {
            const box = document.createElement('div');
            box.classList.add(type === 'pair' ? 'pair-box' : 'edge-box');
            box.dataset.index = index;
            box.dataset.u = u;
            box.dataset.v = v;
            
            // Add SVG visualization
            box.innerHTML = `
                <svg class="mini-svg" viewBox="0 0 100 100">
                    ${drawMiniPolygon(u, v, type)}
                </svg>
            `;
            
            if (type === 'pair') {
                box.dataset.canonicalId = generateCanonicalEdgeId(u, v);
                box.addEventListener('click', () => handlePairSelect(box, index));
            } else { // type === 'edge'
                box.dataset.canonicalId = canonicalId;
                box.addEventListener('click', () => handleEdgeSelect(box));
            }

            return box;
        }
        
        function drawMiniPolygon(u, v, type) {
            let svgContent = '';
            
            // Draw all inactive edges
            for (let i = 0; i < VERTICES_IDS.length; i++) {
                for (let j = i + 1; j < VERTICES_IDS.length; j++) {
                    const p1 = verticesData[i];
                    const p2 = verticesData[j];
                    
                    const isTargetEdge = (i === Math.min(u,v) && j === Math.max(u,v));

                    svgContent += `<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" 
                        class="mini-edge ${type === 'edge' && isTargetEdge ? 'highlight-edge' : ''}" />`;
                }
            }

            // Draw vertices
            for (let i of VERTICES_IDS) {
                const p = verticesData[i];
                let vertexClass = 'mini-vertex';
                
                // Add specific highlights for the pair box
                if (type === 'pair') {
                    if (i === u) vertexClass += ' highlight-u';
                    else if (i === v) vertexClass += ' highlight-v';
                }
                
                svgContent += `<circle cx="${p.x}" cy="${p.y}" r="4" class="${vertexClass}" />`;
            }

            return svgContent;
        }

        // --- Interaction Handlers ---

        function handlePairSelect(box, id) {
            if (box.classList.contains('matched-target')) return; // Already matched

            // Deselect previous pair
            if (selectedPairId !== null) {
                document.querySelector(`.pair-box[data-index="${selectedPairId}"]`).classList.remove('selected');
            }
            
            // Select new pair
            selectedPairId = id;
            box.classList.add('selected');
            setStatus("Pair selected. Now click the corresponding edge on the right.", "normal");
        }

        function handleEdgeSelect(edgeBox) {
            if (selectedPairId === null) {
                setStatus("Please select an ordered pair on the left first.", "warning");
                return;
            }

            const pairBox = document.querySelector(`.pair-box[data-index="${selectedPairId}"]`);
            const pairCanonicalId = pairBox.dataset.canonicalId;
            const edgeCanonicalId = edgeBox.dataset.canonicalId;

            // 1. Check if the pair matches the edge
            if (pairCanonicalId === edgeCanonicalId) {
                // SUCCESSFUL MATCH
                
                // Update pair box
                pairBox.classList.remove('selected');
                pairBox.classList.add('matched-target');
                
                // Update edge box
                matches[edgeCanonicalId].push(selectedPairId);
                const count = matches[edgeCanonicalId].length;

                if (count === 1) {
                    // First time this edge is matched
                    setStatus("First match found! Now find the reverse pair that maps to this same edge.", "success");
                } else if (count === 2) {
                    // Second time this edge is matched (2:1 confirmed)
                    edgeBox.classList.add('matched');
                    setStatus("Edge complete! Both pairs matched this edge.", "success");
                }
                
                selectedPairId = null;
                matchedPairsCount++;

                if (matchedPairsCount === TOTAL_PAIRS) {
                    endGame();
                }

            } else {
                // INCORRECT MATCH
                setStatus("Incorrect match. That pair maps to a different edge. Try again!", "error");
                
                // Briefly flash the incorrect edge box
                edgeBox.classList.add('selected'); 
                setTimeout(() => {
                    edgeBox.classList.remove('selected');
                    // Reset selection to force the user to re-select the pair
                    document.querySelector(`.pair-box[data-index="${selectedPairId}"]`).classList.remove('selected');
                    selectedPairId = null;
                    setStatus("Selection reset. Pick a Pair on the left to start.", "normal");
                }, 1000);
            }
        }
        
        // --- Game Flow ---

        function setStatus(text, type) {
            statusMessage.textContent = text;
            statusMessage.className = ''; // Reset class
            statusMessage.classList.add(`status-${type}`);
        }

        function endGame() {
            setStatus("CONGRATULATIONS! You have successfully mapped all 12 pairs to their 6 unique edges.", "success");
            resetBtn.textContent = "Play Again";
        }
        
        function resetGame() {
             location.reload();
        }

        // --- Utility Functions for Status Bar Styling (for clean presentation) ---

        function setStatus(text, type) {
            statusMessage.textContent = text;
            statusMessage.style.color = 'var(--text-main)';
            
            if (type === 'success') {
                statusMessage.style.color = 'var(--success)';
            } else if (type === 'warning') {
                statusMessage.style.color = 'var(--warning)';
            } else if (type === 'error') {
                statusMessage.style.color = 'var(--error)';
            }
        }

        // Start Game
        initGame();

    </script>
</body>
</html>
