<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DAG Path Counting (Principle of Sum)</title>
    <style>
        :root {
            --bg-color: #f8fafc;
            --text-main: #1e293b;
            --edge-line: #94a3b8;
            --vertex-initial: #cbd5e1;
            --vertex-editable: #fff;
            --input-border: #64748b;
            --success: #10b981;
            --error: #ef4444;
            --info: #2563eb;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 { margin-bottom: 0.5rem; }
        p { color: #64748b; margin-bottom: 2rem; text-align: center; max-width: 800px; }

        #game-container {
            position: relative;
            background: #fff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            width: 500px; /* Fixed width for better centering */
            min-height: 600px;
        }
        
        /* --- SVG Edge Styling --- */
        #graph-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows click-through */
            z-index: 10;
        }

        .dag-edge {
            stroke: var(--edge-line);
            stroke-width: 2;
            fill: none;
            /* Optional: Add marker to show direction (downward) */
            marker-end: url(#arrowhead);
        }
        
        /* --- Vertex Input Styling --- */
        .vertex-group {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 40px; 
            height: 40px;
            transform: translate(-50%, -50%);
            z-index: 20; /* Keep circles above SVG edges */
        }

        .vertex-circle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: var(--vertex-editable);
            border: 2px solid var(--input-border);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1rem;
            box-sizing: border-box;
            transition: all 0.3s;
        }

        .vertex-circle.initial {
            background-color: var(--vertex-initial);
            border-color: var(--grid-line);
            color: var(--text-main);
            pointer-events: none;
            cursor: default;
        }

        .vertex-circle.correct {
            background-color: var(--success);
            border-color: var(--success);
            color: white;
        }

        .vertex-circle.incorrect {
            background-color: var(--error);
            border-color: var(--error);
            color: white;
            animation: shake 0.5s;
        }
        
        .vertex-circle input {
            width: 90%;
            height: 90%;
            border: none;
            text-align: center;
            font-size: 1rem;
            font-weight: bold;
            background: transparent;
        }
        
        .vertex-circle.correct input { color: white; }
        .vertex-circle.incorrect input { color: white; }
        
        .label-A, .label-B {
            position: absolute;
            font-weight: bold;
            font-size: 1.1rem;
            color: var(--info);
            pointer-events: none;
        }
        .label-A { top: -20px; }
        .label-B { bottom: -20px; }


        /* --- Status Bar --- */
        #status-bar {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 1.1rem;
            font-weight: 600;
            height: 40px;
            border-radius: 6px;
            color: var(--text-main);
        }

        @keyframes shake {
            0%, 100% { transform: translate(-50%, -50%); }
            20%, 60% { transform: translate(-55%, -50%); }
            40%, 80% { transform: translate(-45%, -50%); }
        }
    </style>
</head>
<body>

    <h1>Generalizing the Sum Principle to Directed Graphs</h1>
    <p>
        The number of simple paths to any vertex is the sum of the path counts of all connected vertices in the **previous** row (which are disjoint paths). <br>
        Find the total number of paths from the start (A) to the end (B).
    </p>

    <div id="game-container">
        <svg id="graph-svg">
            <defs>
                <marker id="arrowhead" viewBox="0 0 10 10" refX="8" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--edge-line)" />
                </marker>
            </defs>
        </svg>
        
        </div>

    <div id="status-bar">Start at the top layer and work your way down.</div>

    <script>
        // --- Configuration ---
        const SVG_NS = "http://www.w3.org/2000/svg";
        const TOTAL_LAYERS = 5; // Layers 0 to 4
        const V_SPACING = 120; // Vertical spacing between layers
        const H_WIDTH = 450; // Total horizontal space for vertices

        // Graph Definition: (Layer index, array of vertex centers relative to layer width)
        // Vertex IDs are generated as a simple index across all layers.
        const layerLayout = [
            { count: 1, yOffset: 50, hCenters: [0.5] }, 
            { count: 3, yOffset: 170, hCenters: [0.2, 0.5, 0.8] },
            { count: 4, yOffset: 290, hCenters: [0.1, 0.35, 0.65, 0.9] },
            { count: 2, yOffset: 410, hCenters: [0.3, 0.7] },
            { count: 1, yOffset: 530, hCenters: [0.5] }
        ];

        // Edges: [Source Vertex ID, Target Vertex ID]
        // Vertex IDs are assigned sequentially starting from 0 (top-down, left-to-right)
        // L0 (0) -> L1 (1, 2, 3)
        // L1 (1, 2, 3) -> L2 (4, 5, 6, 7)
        // L2 (4, 5, 6, 7) -> L3 (8, 9)
        // L3 (8, 9) -> L4 (10)
        const allEdges = [
            [0, 1], [0, 2], [0, 3], 
            [1, 4], [1, 5], 
            [2, 5], [2, 6], 
            [3, 6], [3, 7], 
            [4, 8], [5, 8], [6, 9], [7, 9],
            [8, 10], [9, 10]
        ];


        // --- State and Mapping ---
        const vertices = []; // Array of {id, layer, x, y, initial, dependencies: []}
        const correctCounts = {}; // {id: count}
        const userInputs = {};   // {id: input_value}
        let totalVertices = 0;
        
        // --- DOM Elements ---
        const container = document.getElementById('game-container');
        const graphSvg = document.getElementById('graph-svg');
        const statusBar = document.getElementById('status-bar');

        // --- Initialization ---

        function initGame() {
            createVertexStructure();
            calculateCorrectCounts();
            renderEdges();
            renderVertices();
            updateInputStates();
        }
        
        // 1. Map vertex structure and calculate screen coordinates
        function createVertexStructure() {
            let idCounter = 0;
            const containerWidth = container.offsetWidth;

            layerLayout.forEach((layer, lIdx) => {
                layer.hCenters.forEach((hCenter, vIdx) => {
                    const v = {
                        id: idCounter,
                        layer: lIdx,
                        x: hCenter * H_WIDTH + 20, // 20 is left padding
                        y: layer.yOffset,
                        initial: (lIdx === 0), // Only start node is initialized
                        dependencies: [], // Filled in the next step
                    };
                    vertices[idCounter] = v;
                    idCounter++;
                });
            });
            totalVertices = idCounter;
            
            // Map dependencies (incoming edges)
            allEdges.forEach(([sourceId, targetId]) => {
                vertices[targetId].dependencies.push(sourceId);
            });
        }

        // 2. Calculate correct answers using the Principle of Sum/Recurrence
        function calculateCorrectCounts() {
            vertices.forEach(v => {
                if (v.initial) {
                    correctCounts[v.id] = 1;
                } else {
                    let count = 0;
                    // Sum the correct path counts of all predecessors
                    v.dependencies.forEach(predId => {
                        count += correctCounts[predId];
                    });
                    correctCounts[v.id] = count;
                }
            });
        }

        // 3. Render edges
        function renderEdges() {
            allEdges.forEach(([sourceId, targetId]) => {
                const source = vertices[sourceId];
                const target = vertices[targetId];

                const line = document.createElementNS(SVG_NS, 'line');
                line.setAttribute('x1', source.x);
                line.setAttribute('y1', source.y + 15); // Start slightly below circle
                line.setAttribute('x2', target.x);
                line.setAttribute('y2', target.y - 15); // End slightly above circle
                line.classList.add('dag-edge');
                graphSvg.appendChild(line);
            });
        }

        // 4. Render vertices
        function renderVertices() {
            vertices.forEach(v => {
                const group = document.createElement('div');
                group.classList.add('vertex-group');
                group.style.left = `${v.x}px`;
                group.style.top = `${v.y}px`;
                group.dataset.id = v.id;
                
                const circle = document.createElement('div');
                circle.classList.add('vertex-circle');

                if (v.initial) {
                    circle.classList.add('initial', 'correct');
                    circle.textContent = '1';
                    userInputs[v.id] = 1;
                    
                    const labelA = document.createElement('div');
                    labelA.textContent = 'A (Start)';
                    labelA.classList.add('label-A');
                    group.appendChild(labelA);
                } else {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.min = 0;
                    input.maxLength = 5;
                    input.id = `input-${v.id}`;
                    input.dataset.id = v.id;
                    input.disabled = true; 
                    
                    input.addEventListener('input', handleInput);
                    input.addEventListener('focus', handleFocus);
                    circle.appendChild(input);

                    if (v.id === totalVertices - 1) {
                         const labelB = document.createElement('div');
                         labelB.textContent = 'B (End)';
                         labelB.classList.add('label-B');
                         group.appendChild(labelB);
                    }
                }
                
                group.appendChild(circle);
                container.appendChild(group);
            });
        }

        // --- Game Logic ---

        function updateInputStates() {
            let solvedCount = 1; // Start node is already solved
            let enabledCount = 0;

            for (let id = 1; id < totalVertices; id++) {
                const v = vertices[id];
                const inputEl = document.getElementById(`input-${v.id}`);
                if (!inputEl) continue;

                if (userInputs[id] !== undefined && userInputs[id] !== null) {
                    // Already solved
                    solvedCount++;
                    inputEl.disabled = true;
                    continue;
                }

                // Check dependencies: Are all predecessors solved?
                const allDepsSolved = v.dependencies.every(depId => 
                    userInputs[depId] !== undefined && userInputs[depId] !== null
                );

                if (allDepsSolved) {
                    inputEl.disabled = false;
                    inputEl.style.color = 'var(--text-main)';
                    enabledCount++;
                } else {
                    inputEl.disabled = true;
                }
            }
            
            if (solvedCount === totalVertices) {
                endGame();
            } else if (enabledCount > 0) {
                statusBar.textContent = `You have ${enabledCount} available vertices to calculate. Sum the path counts of the connected vertices above!`;
            } else {
                 statusBar.textContent = "Work layer by layer, starting from the top.";
            }
        }

        function handleFocus(event) {
             const input = event.target;
             const circle = input.parentElement;
             circle.classList.remove('incorrect');
             circle.style.animation = 'none';
        }

        function handleInput(event) {
            const input = event.target;
            const id = parseInt(input.dataset.id);
            const value = parseInt(input.value.trim());
            const circle = input.parentElement;
            const v = vertices[id];

            circle.classList.remove('correct', 'incorrect');
            circle.style.animation = 'none'; 
            input.style.color = 'var(--text-main)';

            if (isNaN(value)) {
                userInputs[id] = null;
                updateInputStates();
                return;
            }

            if (value === correctCounts[id]) {
                circle.classList.add('correct');
                input.value = value;
                input.disabled = true; 
                userInputs[id] = value;
                
                setStatus(`Correct! The path count to Vertex ${id + 1} is ${value}.`, 'success');
            } else {
                circle.classList.add('incorrect');
                input.value = ''; 
                
                // Provide hint about the required sum
                const predecessors = v.dependencies.map(predId => userInputs[predId]);
                const hintText = predecessors.join(' + ') + ` = ?`;

                setStatus(`Incorrect. Check your sum: (${hintText})`, 'error');
                circle.style.animation = 'shake 0.5s';
                userInputs[id] = null;
            }
            
            updateInputStates();
        }

        function setStatus(text, type) {
            statusBar.textContent = text;
            statusBar.style.color = type === 'error' ? 'var(--error)' : 
                                     type === 'success' ? 'var(--success)' : 
                                     'var(--text-main)';
        }

        function endGame() {
            const finalCount = correctCounts[totalVertices - 1];
            setStatus(`GAME COMPLETE! The total number of paths from A to B is ${finalCount}.`, 'success');
            document.querySelectorAll('input').forEach(input => input.disabled = true);
        }

        // Start
        initGame();
    </script>
</body>
</html>
